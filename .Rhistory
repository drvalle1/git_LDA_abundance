nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
gamma=get.gamma(vmat=vmat,ncomm=ncomm,pot.gamma=pot.gamma)
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
gamma.out[i]=gamma
}
table(gamma.out)
boxplot(theta)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta[,i],col=i)
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:ncommun]=diag(8,ncommun)
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=30,max=120))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_abundance')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
ncomm=10
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
gamma=0.1;
#gibbs details
ngibbs=1000
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
}
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=200))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_abundance')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
ncomm=10
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
gamma=0.1;
#gibbs details
ngibbs=1000
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
}
plot(llk,type='l',ylim=range(llk,na.rm=T))
boxplot(theta)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta[,i],col=i)
theta1=c(2,3,4,1,5)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta1[,i],col=i)
ind=c(2,3,4,1,5)
theta1=theta[,ind]
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta1[,i],col=i)
plot(phi.true,phi[ind,])
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta[,i],col=i)
ind=c(2,3,4,1,5)
theta1=theta[,ind]
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta1[,i],col=i)
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=200))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=100
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=200))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_abundance')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome)
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
ncomm=10
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
gamma=0.1;
#gibbs details
ngibbs=1000
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
}
plot(llk,type='l',ylim=range(llk,na.rm=T))
boxplot(theta)
ind=c(2,3,4,1,5)
theta1=theta[,ind]
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncomm) lines(1:nloc,theta1[,i],col=i)
plot(phi.true,phi[ind,])
