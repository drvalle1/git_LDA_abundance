pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=-1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=-1
a1.store=rep(NA,niter)
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
warnings()
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(density(a1.store),type='l')
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
plot(density(a1.store),type='l')
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=2
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new) #reflect proposal if negative
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.0001
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new) #reflect proposal if negative
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
library(circular)
?dvonmises
data1 <- rvonmises(1000, circular(0), 10, control.circular=list(units="degrees"))
plot(data1)
ff <- function(x) dvonmises(x, mu=circular(pi), kappa=10)
curve.circular(ff, join=TRUE, xlim=c(-2.3, 1),
main="Density of a VonMises Distribution \n mu=pi, kappa=10")
x=seq(from=0,to=2*pi,length.out=1000)
y=dvonmises(x, mu=circular(pi), kappa=10)
plot(x,y)
x=seq(from=0,to=2*pi,length.out=1000)
y=dvonmises(x, mu=circular(2*pi*0.99), kappa=10)
plot(x,y)
plot(res$NBN,type='l')
?rnbinom
nobs=10000
n=3
mu=10
x=rnbinom(nobs,mu=mu,size=n)
p=n/(mu+n)
mean(x); mu
var(x); n*(1-p)/(p^2)
n=3
mu=10
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=3
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=25
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
p
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.01
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.01
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
z=3
mu=2
sig2=2
dnorm(z,mean=mu,sd=sqrt(sig2),log=T)
dnorm(2*z,mean=2*mu,sd=2*sqrt(sig2),log=T)
e.star=3
mu=2
sig2=2
pnorm(e.star,mean=mu,sd=sqrt(sig2),log=T)
e.star=3
mu.star=2
sig2.star=2
pnorm(e.star,mean=mu.star,sd=sqrt(sig2.star))
e.star=3
mu.star=2
sig2.star=2
pnorm(e.star,mean=mu.star,sd=sqrt(sig2.star))
sig2=1
e=e.star/sqrt(sig2.star)
mu=mu.star/sqrt(sig2.star)
pnorm(e,mean=mu,sd=sqrt(sig2),log=T)
e.star=3
mu.star=2
sig2.star=2
pnorm(e.star,mean=mu.star,sd=sqrt(sig2.star))
sig2=1
e=e.star/sqrt(sig2.star)
mu=mu.star/sqrt(sig2.star)
pnorm(e,mean=mu,sd=sqrt(sig2))
library('devtools')
install.packages('devtools')
library('devtools')
install_github('drvalle1/EcoCluster',build_vignettes=T)
library('devtools')
install_github('drvalle1/EcoCluster',build_vignettes=T)
install.packages('tinytex')
tinytex::install_tinytex()
tinytex:::is_tinytex()
devtools::install_github("joshcullen/bayesmove")
install.packages('backports')
devtools::install_github("joshcullen/bayesmove")
install.packages('Rtools')
devtools::install_github("joshcullen/bayesmove")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
devtools::install_github("joshcullen/bayesmove")
install.packages('backports')
devtools::install_github("joshcullen/bayesmove")
devtools::install_github("joshcullen/bayesmove")
install.packages('devtools')
install.packages("devtools")
library('devtools')
sessionInfo()
devtools::install_github("joshcullen/bayesmove")
library(devtools)
install_github("gilsonshimizu/ldacov",auth_token = "1e039dbc6f5c0832b2fc11a5d88882ce3dbcf2ec")
rm(list=ls())
library('lidR')
setwd('U:\\independent studies\\LIDAR')
las = readLAS('TAN_A01_2014_laz_1.laz',select='xyz')
str(las@data)
# plot(las)
rangox=range(las@data$X); diff(rangox)
rangoy=range(las@data$Y); diff(rangoy)
rangoz=range(las@data$Z); diff(rangoz)
dat=cbind(las@data$X,las@data$Y,las@data$Z)
colnames(dat)=c('x','y','z')
#get xnew
seq.x=seq(from=rangox[1],to=rangox[2],length.out=100)
diff1=(seq.x[2]-seq.x[1])/2
mid.x=seq.x[-length(seq.x)]+diff1
tmp=as.numeric(cut(dat[,'x'],breaks=seq.x))
xnew=mid.x[tmp]
#get ynew
seq.y=seq(from=rangoy[1],to=rangoy[2],length.out=100)
diff1=(seq.y[2]-seq.y[1])/2
mid.y=seq.y[-length(seq.y)]+diff1
tmp=as.numeric(cut(dat[,'y'],breaks=seq.y))
ynew=mid.y[tmp]
#create new dataset
dat1=cbind(dat,xnew,ynew)
i=j=1
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
print(c(i,j,sum(cond)))
head(dat1)
sum(cond,na.rm=T)
range(seq.x)
unique(tmp)
unique()
unique(cut(dat[,'y'],breaks=seq.y))
seq.y=seq(from=rangoy[1],to=rangoy[2]+1,length.out=100)
diff1=(seq.y[2]-seq.y[1])/2
mid.y=seq.y[-length(seq.y)]+diff1
tmp=as.numeric(cut(dat[,'y'],breaks=seq.y))
unique(cut(dat[,'y'],breaks=seq.y))
sum(is.na(dat[,'x']))
sum(is.na(dat[,'y']))
?cut
seq.x=seq(from=rangox[1],to=rangox[2],length.out=100)
diff1=(seq.x[2]-seq.x[1])/2
mid.x=seq.x[-length(seq.x)]+diff1
k=cut(dat[,'x'],breaks=seq.x)
unique(k)
which(is.na(cut(dat[,'x'],breaks=seq.x)))
ind=which(is.na(cut(dat[,'x'],breaks=seq.x)))
unique(dat[ind,'x'])
rangox
seq.x=seq(from=rangox[1]-0.1,to=rangox[2],length.out=100)
diff1=(seq.x[2]-seq.x[1])/2
mid.x=seq.x[-length(seq.x)]+diff1
tmp=as.numeric(cut(dat[,'x'],breaks=seq.x))
sum(is.na(tmp))
rm(list=ls())
library('lidR')
setwd('U:\\independent studies\\LIDAR')
las = readLAS('TAN_A01_2014_laz_1.laz',select='xyz')
str(las@data)
# plot(las)
rangox=range(las@data$X); diff(rangox)
rangoy=range(las@data$Y); diff(rangoy)
rangoz=range(las@data$Z); diff(rangoz)
dat=cbind(las@data$X,las@data$Y,las@data$Z)
colnames(dat)=c('x','y','z')
#get xnew
seq.x=seq(from=rangox[1]-0.0001,to=rangox[2],length.out=100)
diff1=(seq.x[2]-seq.x[1])/2
mid.x=seq.x[-length(seq.x)]+diff1
tmp=as.numeric(cut(dat[,'x'],breaks=seq.x))
xnew=mid.x[tmp]
#get ynew
seq.y=seq(from=rangoy[1]-0.0001,to=rangoy[2],length.out=100)
diff1=(seq.y[2]-seq.y[1])/2
mid.y=seq.y[-length(seq.y)]+diff1
tmp=as.numeric(cut(dat[,'y'],breaks=seq.y))
ynew=mid.y[tmp]
#create new dataset
dat1=cbind(dat,xnew,ynew)
znew=rep(NA,nrow(dat1))
i=j=1
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
print(c(i,j,sum(cond)))
znew=rep(NA,nrow(dat1))
for (i in 1:length(mid.y)){
for (j in 1:length(mid.x)){
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
print(c(i,j,sum(cond)))
min1=min(dat1[cond,'z'])
znew[cond]=dat1[cond,'z']-min1
}
}
warnings()
znew=rep(NA,nrow(dat1))
for (i in 1:length(mid.y)){
for (j in 1:length(mid.x)){
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
soma=sum(cond)
print(c(i,j,soma))
if (soma>0){
min1=min(dat1[cond,'z'])
znew[cond]=dat1[cond,'z']-min1
}
}
}
dat1=cbind(dat,xnew,ynew)
#change z to account for ground data
znew=rep(NA,nrow(dat1))
for (i in 1:length(mid.y)){
for (j in 1:length(mid.x)){
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
soma=sum(cond)
print(c(i,j,soma))
if (soma>0){
min1=min(dat1[cond,'z'])
znew[cond]=dat1[cond,'z']-min1
}
}
}
dat1=cbind(dat,xnew,ynew)
#change z to account for ground data
znew=rep(NA,nrow(dat1))
for (i in 1:length(mid.y)){
for (j in 1:length(mid.x)){
cond=mid.y[i]==dat1[,'ynew'] &
mid.x[j]==dat1[,'xnew']
soma=sum(cond)
print(c(i,j,soma))
if (soma>0){
min1=min(dat1[cond,'z'])
znew[cond]=dat1[cond,'z']-min1
}
}
}
tmp=aggregate(z~xnew+ynew,data=dat1,min)
denis=1
dat2=cbind(dat,xnew,ynew,denis)
tmp1=aggregate(denis~xnew+ynew,data=dat1,sum)
tmp2=merge(tmp,tmp1,all=T); dim(tmp); dim(tmp1); dim(tmp2)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(33)
#get data
setwd('U:\\independent studies\\LIDAR\\cauaxi edited\\2012')
dat=read.csv('CAU 2012 edited2.csv',as.is=T)
ind=which(colnames(dat)%in%c('xnew','ynew'))
y=data.matrix(dat[,-ind])
#basic settings
ncomm.init=10
ngibbs=10
ngibbs=100
nburn=ngibbs/2
#priors
psi=0.01
gamma=0.1
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm.init,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
dim(res$array.lsk)
nloc
nloc=nrow(y)
nspp=ncol(y)
nloc
nspp
