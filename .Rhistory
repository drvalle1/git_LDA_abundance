write.csv(xmat,nome,row.names=F)
image(y[1:10,])
image(y)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(12)
#get data
setwd('U:\\GIT_models\\LdaPoisson_nocov')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=10
ngibbs=1000
nburn=ngibbs/2
#priors
psi=phi.prior=0.01
a.gamma=b.gamma=0.1
var.betas=10
gamma=0.1
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#determine optimal number of groups
nlk=apply(array.lsk.init,c(1,3),sum)
theta=nlk/apply(nlk,1,sum)
par(mfrow=c(1,1),mar=c(3,3,1,1))
boxplot(theta)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(2)
nloc=1000
nspp=100
ncommun=8
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-3,max=3),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
# image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=4,max=7)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h',ylim=c(0,1))
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\LdaPoisson_nocov')
nome='fake data.csv'
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome,row.names=F)
nome='fake data xmat.csv'
write.csv(xmat,nome,row.names=F)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(2)
nloc=1000
nspp=100
ncommun=8
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-3,max=3),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
# image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=4,max=7)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(2)
nloc=1000
nspp=100
ncommun=8
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-3,max=3),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
# image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=4,max=7)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h',ylim=c(0,1))
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\LdaPoisson_nocov')
nome='fake data.csv'
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome,row.names=F)
nome='fake data xmat.csv'
write.csv(xmat,nome,row.names=F)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(12)
#get data
setwd('U:\\GIT_models\\LdaPoisson_nocov')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=10
ngibbs=1000
nburn=ngibbs/2
#priors
psi=phi.prior=0.01
a.gamma=b.gamma=0.1
var.betas=10
gamma=0.1
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#determine optimal number of groups
nlk=apply(array.lsk.init,c(1,3),sum)
theta=nlk/apply(nlk,1,sum)
par(mfrow=c(1,1),mar=c(3,3,1,1))
boxplot(theta)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(2)
nloc=1000
nspp=100
ncommun=3
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-3,max=3),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
# image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=4,max=7)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h',ylim=c(0,1))
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\LdaPoisson_nocov')
nome='fake data.csv'
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome,row.names=F)
nome='fake data xmat.csv'
write.csv(xmat,nome,row.names=F)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(20)
nloc=1000
nspp=100
ncommun=3
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-3,max=3),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
# image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=4,max=7)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.9,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h',ylim=c(0,1))
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\LdaPoisson_nocov')
nome='fake data.csv'
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome,row.names=F)
nome='fake data xmat.csv'
write.csv(xmat,nome,row.names=F)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(12)
#get data
setwd('U:\\GIT_models\\LdaPoisson_nocov')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=10
ngibbs=1000
nburn=ngibbs/2
#priors
psi=phi.prior=0.01
a.gamma=b.gamma=0.1
var.betas=10
gamma=0.1
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#determine optimal number of groups
nlk=apply(array.lsk.init,c(1,3),sum)
theta=nlk/apply(nlk,1,sum)
par(mfrow=c(1,1),mar=c(3,3,1,1))
boxplot(theta)
