rm(list=ls(all=TRUE))
set.seed(1)
#create prior probability for location
nloc=20
seq1=1:nloc
combo=expand.grid(x=seq1,y=seq1)
combo$prob=dnorm(combo$x,mean=3,sd=2)*dnorm(combo$y,mean=3,sd=2)
combo$prob=combo$prob/sum(combo$prob)
#some useful things
nsim=1000
nsteps=10000
#probability of finding given presence
theta=0.2
#to store results
res.random=rep(NA,nsim)
for (i in 1:nsim){
#location of submarine
ind=rmultinom(1,size=1,prob=combo$prob)
ind1=which(ind==1)
x.submarine=combo$x[ind1]
y.submarine=combo$y[ind1]
for (j in 1:nsteps){
#choose a location at random
ind=sample(1:nrow(combo),size=1)
xsel=combo$x[ind]; ysel=combo$y[ind]
#did you find it?
if (xsel==x.submarine & ysel==y.submarine){
z=rbinom(1,size=1,prob=theta)
if (z==1){
res.random[i]=j
break;
}
}
}
}
hist(res.random)
table(res.random)
rm(list=ls(all=TRUE))
set.seed(1)
#create prior probability for location
nloc=20
seq1=1:nloc
combo=expand.grid(x=seq1,y=seq1)
combo$prob=dnorm(combo$x,mean=3,sd=2)*dnorm(combo$y,mean=3,sd=2)
combo$prob=combo$prob/sum(combo$prob)
#some useful things
nsim=1000
nsteps=10000
#probability of finding given presence
theta=0.1
#to store results
res.random=rep(NA,nsim)
for (i in 1:nsim){
print(i)
#location of submarine
ind=rmultinom(1,size=1,prob=combo$prob)
ind1=which(ind==1)
x.submarine=combo$x[ind1]
y.submarine=combo$y[ind1]
for (j in 1:nsteps){
#choose a location at random
ind=sample(1:nrow(combo),size=1)
xsel=combo$x[ind]; ysel=combo$y[ind]
#did you find it?
if (xsel==x.submarine & ysel==y.submarine){
z=rbinom(1,size=1,prob=theta)
if (z==1){
res.random[i]=j
break;
}
}
}
}
rm(list=ls(all=TRUE))
set.seed(1)
#create prior probability for location
nloc=25
seq1=1:nloc
combo=expand.grid(x=seq1,y=seq1)
combo$prob=dnorm(combo$x,mean=3,sd=2)*dnorm(combo$y,mean=3,sd=2)
combo$prob=combo$prob/sum(combo$prob)
rm(list=ls(all=TRUE))
set.seed(1)
#create prior probability for location
nloc=5
seq1=1:nloc
combo=expand.grid(x=seq1,y=seq1)
combo$prob=dnorm(combo$x,mean=3,sd=2)*dnorm(combo$y,mean=3,sd=2)
combo$prob=combo$prob/sum(combo$prob)
nsim=1000
nsteps=10000
#probability of finding given presence
theta=0.1
#to store results
res.random=rep(NA,nsim)
for (i in 1:nsim){
print(i)
#location of submarine
ind=rmultinom(1,size=1,prob=combo$prob)
ind1=which(ind==1)
x.submarine=combo$x[ind1]
y.submarine=combo$y[ind1]
for (j in 1:nsteps){
#choose a location at random
ind=sample(1:nrow(combo),size=1)
xsel=combo$x[ind]; ysel=combo$y[ind]
#did you find it?
if (xsel==x.submarine & ysel==y.submarine){
z=rbinom(1,size=1,prob=theta)
if (z==1){
res.random[i]=j
break;
}
}
}
}
hist(res.random)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
#get data
setwd('U:\\GIT_models\\git_LDA_abundance')
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
ncomm=5
#get phi
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=read.csv('theta true.csv',as.is=T)
#run folding operation
ngibbs=1000
nburn=ngibbs/2
gamma=0.1
head(theta)
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#gibbs details
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#gibbs details
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
# log.prior=rep(NA,ngibbs)
options(warn=2)
zeroes=array(0,dim=c(nloc,nspp,ncomm))
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial value
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
# log.prior=rep(NA,ngibbs)
options(warn=2)
zeroes=array(0,dim=c(nloc,nspp,ncomm))
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp, zeroes=zeroes)
array.lsk=tmp$ArrayLSK
nlk=tmp$nlk
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=data.matrix(read.csv('theta true.csv',as.is=T))
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp, zeroes=zeroes)
array.lsk=tmp$ArrayLSK
nlk=tmp$nlk
nks=tmp$nks
# nks=nks.true
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
#get data
setwd('U:\\GIT_models\\git_LDA_abundance')
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
ncomm=5
#get phi
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=data.matrix(read.csv('theta true.csv',as.is=T))
#run folding operation
ngibbs=1000
nburn=ngibbs/2
gamma=0.1
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial value
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
options(warn=2)
zeroes=array(0,dim=c(nloc,nspp,ncomm))
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp, zeroes=zeroes)
array.lsk=tmp$ArrayLSK
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
#get data
setwd('U:\\GIT_models\\git_LDA_abundance')
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
ncomm=5
#get phi
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=data.matrix(read.csv('theta true.csv',as.is=T))
#run folding operation
ngibbs=1000
nburn=ngibbs/2
gamma=0.1
res=phi.given.theta(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,theta=theta,gamma=gamma)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
#get data
setwd('U:\\GIT_models\\git_LDA_abundance')
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
ncomm=5
#get phi
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=data.matrix(read.csv('theta true.csv',as.is=T))
#run folding operation
ngibbs=1000
nburn=ngibbs/2
psi=0.1
res=phi.given.theta(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,theta=theta,psi=psi)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
setwd('U:\\GIT_models\\git_LDA_abundance\\phi given theta')
source('estimate phi given theta function.R')
#get data
setwd('U:\\GIT_models\\git_LDA_abundance')
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
ncomm=5
#get phi
setwd('U:\\GIT_models\\git_LDA_abundance')
theta=data.matrix(read.csv('theta true.csv',as.is=T))
#run folding operation
ngibbs=1000
nburn=ngibbs/2
psi=0.1
res=phi.given.theta(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,theta=theta,psi=psi)
str(res)
plot(res$llk,type='l')
seq1=1:nrow(res$phi)
phi=colMeans(res$phi[seq1,])
phi=colMeans(res$phi[seq1,])
phi1=matrix(phi,ncol(theta),ncol(y))
phi.true=read.csv('phi true.csv',as.is=T)
plot(phi1,phi.true)
dim(phi1)
dim(phi.true)
phi.true=data.matrix(read.csv('phi true.csv',as.is=T))
plot(phi1,phi.true)
phi.true=data.matrix(read.csv('phi true.csv',as.is=T))
plot(phi1,phi.true)
hist(phi1-phi.true)
